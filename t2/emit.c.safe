/*
 * IGES "code" emit
 */

#include <stdio.h>
#include "stdarg.h"
#include <string.h>
#include "t2.h"
#include "iges.h"

extern char *globalConstants[];
extern int parcelStackCount;
extern int globalFlag;
extern char *fileName;

int sequence = 0;
extern int deCount;
int parameterCount = 1;
struct LINE *lastLine, *firstLine;
int globalCount;

void PrintParcel(struct PARCEL *theParcel);
void PushParcel(struct PARCEL *theParcel);
struct PARCEL *NewParcel();
struct DE *NewDE(int type, int parameter, int count, int form, int transform);

void EmitStart(void);
void EmitFinish(void);
struct DE *EmitEntities(struct ENTITY *root, struct MATERIAL_VALUES *properties);
struct DE *EmitEntity(int type, int form, int count, ...);
struct DE *EmitPointerEntity(int type, int transform, int count, ...);
struct DE *EmitMatrixEntity(struct ENTITY *translation, struct ENTITY *rotation);
void EmitForm(char *line, char section);
void EmitGlobals(void);
void AddToForm(char line[], char *addition);
void DontCare(char line[]);
void EmitLine(char *string, char section, int de);

char *strdup();

void EmitIGES(struct ENTITY *top)
{
	EmitStart();
	EmitGlobals();
	EmitEntities(top, Null_struct(MATERIAL_VALUES));
	EmitFinish();
} /* end EmitIGES */

void EmitFx(struct ENTITY *top)
{
} /* end EmitFx */

void EmitStart()
{
	if (globalConstants[0]) EmitForm(globalConstants[0], 'S');
	else EmitForm("t square output", 'S');
} /* end EmitStart */

void EmitGlobals()
{
	int i;
	char line[72];
	char format[72];
	line[0] = '\0';
	for (i=1; i<MAXGLOBALS; i++)
	    switch (i) {
	case 1:
		strcat(line, "1H,"); continue;
	case 2:
		AddToForm(line, "1H;"); continue;
	case 3: case 15: case 21: case 22:
		if (globalConstants[i]) {
		    sprintf(format, "%dH%s", strlen(globalConstants[i]), globalConstants[i]);
		    AddToForm(line, format);
		} /* end if */
		continue;
	case 4:	sprintf(format, "%dH%s", strlen(fileName), fileName);
		AddToForm(line, format); continue;
	case 5:	AddToForm(line, "2Ht2"); continue;
	case 6: AddToForm(line, "1H0"); continue;
	case 7: AddToForm(line, "32"); continue;
	case 8: case 9: case 10: case 11: case 12: case 13:
		DontCare(line); continue;
	case 14: case 16: case 17:
		DontCare(line); continue;
	default:
		DontCare(line); continue;
	} /* end switch */
	AddToForm(line, ";");
	EmitForm(line, 'G');
	globalFlag++;
	globalCount = 1;
	sequence = 0;
} /* end EmitGlobals */

struct DE *EmitEntities(struct ENTITY *root, struct MATERIAL_VALUES *inherited)
{
	struct DE *left, *right, *center;
	if (root == Null_struct(ENTITY)) return(Null_struct(DE));
	else
	if (root -> de) return(root -> de);
	switch (root -> type) {
	case IGES_CSG:
	case IGES_ASSEMBLY:
		left = EmitEntities(root -> entity.csg -> left);
		right = EmitEntities(root -> entity.csg -> right);
		center = EmitPointerEntity(root -> type, 0, 2, -left -> subscript, -right -> subscript);
		break;
	case IGES_TRANSFORMATION:
		left = EmitEntities(root -> entity.transformation -> node);
		right = EmitMatrixEntity(root -> entity.transformation -> translation, root -> entity.transformation -> rotation);
		center = EmitPointerEntity(root -> type, right ? right -> subscript : 0, 1, -left -> subscript);
		break;
	case IGES_BLOCK:
		center = EmitEntity(root -> type, 0, 3,
			root -> entity.block  -> length[0],
			root -> entity.block  -> length[1],
			root -> entity.block  -> length[2]);
		break;
	case IGES_SPHERE:
		center = EmitEntity(root -> type, 0, 1, root -> entity.sphere  -> radius);
		break;
	case IGES_POINT:
		center = EmitEntity(root -> type, 0, 3,
			root -> entity.point  -> point.vector[0],
			root -> entity.point  -> point.vector[1],
			root -> entity.point  -> point.vector[2]);
		break;
	case IGES_CYLINDER:
		center = EmitEntity(root -> type, 0, 2,
			root -> entity.cylinder  -> height,
			root -> entity.cylinder  -> radius);
		break;
	default:
		fprintf(stderr, "type=%d\n", root -> type);
		Bug("unknown type in EmitEntities");
	} /* end switch */
	root -> de = center;
	return(center);
} /* end EmitEntities */

void EmitForm(char *input_line, char section)
{
	char line[81];
	int length;
	length = strlen(input_line);
	strncpy(line, input_line, 72);
	memset(line + length, ' ', 80-length-1);
	sprintf(line+72, "%c%07.7d", section, 1);
	line[80] = '\0';
	printf("%s\n", line);
} /* end EmitForm */

void AddToForm(char line[], char *addition)
{
	strcat(line, ",");
	if ((strlen(line) + strlen(addition) + 1)>= 72) {
		EmitForm(line, 'G');
		strncpy(line, addition, 72);
	}
	else strcat(line, addition);
} /* end AddToForm */

void DontCare(char line[])
{
	if (strlen(line)+1 >= 72)
		EmitForm(line, 'G');
	strcat(line, ",");
} /* end DontCare */

void AddFloatToLine(char *line, char *format, int de, float argument)
{
	char addition[65];
	sprintf(addition, format, argument);
	if (strlen(line) + strlen(addition) + 1 > 64) {
		EmitLine(line, 'P', de);
		strncpy(line, addition, 64);
	}
	else strcat(line, addition);
} /* end AddFloatToLine */

void AddIntToLine(char *line, char *format, int de, int argument)
{
	char addition[65];
	sprintf(addition, format, argument);
	if (strlen(line) + strlen(addition) + 1 > 64) {
		EmitLine(line, 'P', de);
		strncpy(line, addition, 64);
	}
	else strcat(line, addition);
} /* end AddIntToLine */

struct DE *EmitEntity(int type, int form, int count, ...)
{
	va_list ap;
	char format[65];
	int i;
	float next, last;
	struct DE *de;
	struct PARCEL *newParcel;
	de = NewDE(type, parameterCount++, 0, form, 0);
	va_start(ap, count);
	sprintf(format, "%d, ", type);
	for (i=0; i<count-1; i++)
		AddFloatToLine(format, "%f,", deCount, va_arg(ap, float));
	AddFloatToLine(format, "%f;", deCount, va_arg(ap, float));
	EmitLine(format, 'P', deCount);
	va_end(ap);
	newParcel = NewParcel(DE_PARCEL);
	newParcel -> ptr.de = de;
	deCount += 2;
	va_end(ap);
	return(de);
} /* end EmitEntity */

struct DE *EmitPointerEntity(int type, int transform, int count, ...)
{
	va_list ap;
	char format[65];
	int i;
	float next, last;
	struct DE *de;
	struct PARCEL *newParcel;
	de = NewDE(type, parameterCount++, 0, 0, transform);
	va_start(ap, count);
	sprintf(format, "%d, ", type);
	for (i=0; i<count-1; i++)
		AddIntToLine(format, "%d,", deCount, va_arg(ap, int));
	AddIntToLine(format, "%d;", deCount, va_arg(ap, int));
	EmitLine(format, 'P', deCount);
	newParcel = NewParcel(DE_PARCEL);
	newParcel -> ptr.de = de;
	deCount += 2;
	va_end(ap);
	return(de);
} /* end EmitPointerEntity */

struct DE *EmitMatrixEntity(struct ENTITY *translation, struct ENTITY *rotation)
{
	float matrix[3][4];
	int i,j;
	for (i=0; i<3; i++)
	    for (j=0; j<4; j++)
		matrix[i][j] = (i == j) ? 1.0 : 0.0;
	if (translation) {
		if (translation -> type != IGES_POINT) Bug("translation.type!=POINT");
		for (i=0; i<3; i++)
			matrix[i][i] = translation -> entity.point -> point.vector[i];
	} /* end if */
	if (rotation) {
		if (rotation -> type != IGES_POINT) Bug("rotation.type!=POINT");
		for (i=0; i<3; i++)
			matrix[i][3] = rotation -> entity.point -> point.vector[i];
	} /* end if */
/*	for (i=0; i<3; i++) {
	    for (j=0; j<4; j++)
		fprintf(stderr, "%f ", matrix[i][j]);
	    fprintf(stderr, "\n");
	}
 */
	return(EmitEntity(IGES_MATRIX, 0, 12,
		matrix[0][0], matrix[0][1], matrix[0][2], matrix[0][3],
		matrix[1][0], matrix[1][1], matrix[1][2], matrix[1][3],
		matrix[2][0], matrix[2][1], matrix[2][2], matrix[2][3]));
} /* end EmitMatrixEntity */

void EmitDE(struct DE *theDE)
{
	char *label;
	if (theDE -> label == NULL) label = "";
	printf("%8d%8d%8d%8d%8d%8d%8d%8.8s%8dD%7d\n",
	theDE -> type, theDE -> parameter, theDE -> structure, theDE -> lineFont,
	theDE -> levels, theDE -> view, theDE -> transformation, label, 0, ++sequence);
	printf("%8d%8d%8d%8d%8d%8d%8d%8.8s%8dD%7d\n",
	theDE -> type, theDE -> parameter, theDE -> color, theDE -> count, theDE -> form,
	0, 0, label, theDE -> subscript, ++sequence);
} /* end EmitDE */

void EmitLine(char *string, char section, int de)
{
	struct LINE *line;
	line = Struct_alloc(LINE);
	line -> chain = Null_struct(LINE);
	line -> string = strdup(string);
	line -> de = de;
	if (lastLine) lastLine -> chain = line;
	else firstLine = line;
	lastLine = line;
} /* end EmitLine */

void EmitLines()
{
	while (firstLine) {
		printf("%64.64s%8d%c%7d\n",
			firstLine -> string, firstLine -> de, 'P', ++sequence);
		firstLine = firstLine -> chain;
	} /* end while */
} /* end EmitLines */

void EmitFinish()
{
	if (parcelStackCount != 0) {
		StackTrace();
		Trouble("stack not empty");
	} /* end if */
	sequence = 0;
	EmitLines();
	printf("S%7.7dG%7.7dD%7.7dP%7.7d                                        T%7.7d\n",
	1, globalCount, deCount, sequence, 1);
} /* end EmitFinish */
